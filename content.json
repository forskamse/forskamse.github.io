{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Linux远程桌面服务VNC&#x2F;XRDP&#x2F;Xdmcp&#x2F;SSH+X11转发及其在树莓派上的使用","text":"Linux下有三大知名的远程桌面服务，即VNC/XRDP/Xdmcp，此外还有一个认知度不那么高的SSH+X11转发服务也是很好用的。下面的介绍中我引入在树莓派上的应用（使用Raspbian Stretch），给大家一个直观的认识。 VNC使用VNC服务时，先在树莓派上安装vncserver，然后在PC或其他设备上安装vncviewer。 树莓派上的vncserver有：realvnc、tightvnc、x11vnc等。其实知名的vnc服务提供方还有tigervnc和ultravnc等，只是没有推出arm或树莓派版本。 realvnc在此下载安装：https://www.realvnc.com/en/connect/download/vnc/raspberrypi/tightvnc和x11vnc使用apt-get安装即可： 123sudo apt-get install tightvnc或sudo apt-get install x11vnc realvnc和tightvnc在安装完成后执行： 1vncserver 首次执行，会要求输入密码以及view-only模式密码，输入后生成一个桌面，提示如下： 12......New desktop is raspberrypi:1 (192.168.253.6:1) x11vnc在安装完成后执行: 1234#设置密码x11vnc -storepasswd#启动服务x11vnc -auth guess -once -loop -noxdamage -repeat -rfbauth /home/pi/.vnc/passwd -rfbport 5900 -shared vncviewer可以使用realvnc、tightvnc、ultravnc、tigervnc等提供的vncviewer。 realvnc viewer：https://www.realvnc.com/en/connect/download/viewer/ realvnc提供的vncviewer支持很多设备，同时复制粘贴等功能也相对完善，一般选用realvnc viewer就可以了。 tightvnc viewer：https://www.tightvnc.com/download.php ultravnc viewer：http://www.uvnc.com/downloads.html tigervnc viewer：https://bintray.com/tigervnc/beta/tigervnc XRDPWindows上有一个远程桌面服务（Remote Desktop Protocol，RDP），Linux上类似的RDP服务称为XRDP。 安装方法如下： 1sudo apt-get install xrdp XRDP安装完是默认启动的，开机也会自动启动。 Windows上自带的远程桌面连接可以直接使用： 不过复制粘贴这些功能做的不如vncviewer好。 XdmcpXdmcp（X Display Manager Control Protocol），即X显示管理器控制协议，由DP（Display Manager），即显示管理器。 树莓派上默认使用的是lightdm这个显示管理器，修改其配置以启用Xdmcp： 123sudo nano /etc/lightdm/lightdm.conf#找到XDMCP Server configuration，修改启用项配置，其他端口等配置不必改。enabled=true Xdmcp的客户端方面，我推荐xmanager，下载地址：http://www.xshellcn.com/xiazai.html 建立会话： 此外，也可以使用Mobaxterm： SSH+X11转发这种远程桌面服务方式在服务端方面不需要进行更多的设置，只要SSH能正常访问即可。 客户端方面推荐使用Mobaxterm，只需要在对话中将Remote environment由Interactive shell修改为LXDE desktop，如下： 打开后的效果如下： 使用Putty也是可以的，在会话设置的Connection–SSH–X11下启用X11 forwarding： 打开终端后，执行以下命令： 1startlxde 就可以打开桌面了。 说一句题外话，Mobaxterm是个十分全面的终端软件，无论是明码文字接口Telnet、Rsh，密码文字接口SSH，图形接口Xdmcp（XServer）、RDP（XRDP）、VNC，X11 Forwarding，文件传输FTP、SFTP，甚至是串口Serial都支持。本人强烈推荐。","link":"/2018/07/21/2018-07-12-Linux%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"卷积神经网络重要论文资源合辑","text":"卷积神经网络的前身与早期发展： 1980年日本学者福岛邦彦（Kunihiko Fukushima）提出的神经认知机模型（Neocognitron）Fukushima K, Miyake S. Neocognitron: A self-organizing neural network model for a mechanism of visual pattern recognition[M].Competition and cooperation in neural nets. Springer, Berlin, Heidelberg, 1982: 267-285. 1989年Yann LeCun提出第一个真正意义上的CNN：LeNet 1989LeCun Y, Boser B, Denker J S, et al. Backpropagation applied to handwritten zip code recognition[J]. Neural computation, 1989, 1(4): 541-551. 1998年Yann LeCun在其博士论文中详细介绍了LeNet（又称LeNet-5），影响力巨大LeCun Y, Bottou L, Bengio Y, et al. Gradient-based learning applied to document recognition[J]. Proceedings of the IEEE, 1998, 86(11): 2278-2324. 2012年以来卷积神经网络迎来迅猛发展阶段： 2012年ILSVRC冠军：AlexNet，掀起深度学习计算机视觉狂潮Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C].Advances in neural information processing systems. 2012: 1097-1105. 2013年ILSVRC冠军：ZFNetZeiler M D, Fergus R. Visualizing and understanding convolutional networks[C].European conference on computer vision. Springer, Cham, 2014: 818-833. 2014年ILSVRC冠军：GoogLeNet，提出Inception结构Szegedy C, Liu W, Jia Y, et al. Going deeper with convolutions[C]. Cvpr, 2015. 2014年ILSVRC亚军：VGGNet，亮点是对网络深度的研究Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014. 2015年ILSVRC冠军：ResNet，提出Residual结构He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C].Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778. 卷积神经网络结合改进与瓶颈阶段：合理结合Inception结构与Residual结构的卷积神经网络已经能够达到令人满意的特征提取效果，但是在解释性上却没有更深一步进展。 2016年Google团队结合了Inception结构与Residual 结构，提出Inception-Residual NetSzegedy C, Ioffe S, Vanhoucke V, et al. Inception-v4, inception-resnet and the impact of residual connections on learning[C].AAAI. 2017, 4: 12. 2016年何凯明提出新的ResNet的想法：Identity MappingHe K, Zhang X, Ren S, et al. Identity mappings in deep residual networks[C].European Conference on Computer Vision. Springer, Cham, 2016: 630-645. 2017年DenseNetHuang G, Liu Z, Weinberger K Q, et al. Densely connected convolutional networks[C].Proceedings of the IEEE conference on computer vision and pattern recognition. 2017, 1(2): 3. 轻量级卷积神经网络发展阶段：2016年以来，卷积神经网络开始往轻量化发展，为视觉深度学习模型在移动设备上的应用提供条件。 2016年MobileNetHoward A G, Zhu M, Chen B, et al. Mobilenets: Efficient convolutional neural networks for mobile vision applications[J]. arXiv preprint arXiv:1704.04861, 2017. 2016年ShuffleNetZhang X, Zhou X, Lin M, et al. Shufflenet: An extremely efficient convolutional neural network for mobile devices[J]. arXiv preprint arXiv:1707.01083, 2017. 2016年Xception【注：Xception目标并不是使卷积神经网络轻量化，而是在不增加网络复杂度的情况下提升性能，但其中使用的depthwise convolution思想是MobileNet等轻量级卷积神经网络的关键，故也列在这里】Chollet F. Xception: Deep learning with depthwise separable convolutions[J]. arXiv preprint, 2017: 1610.02357. 2016年ResNeXt【注：ResNeXt也是为了在不增加网络复杂度的情况下提升性能，列在此处的原因与Xception相同】Xie S, Girshick R, Dollár P, et al. Aggregated residual transformations for deep neural networks[C].Computer Vision and Pattern Recognition (CVPR), 2017 IEEE Conference on. IEEE, 2017: 5987-5995. 论文合集GitHub地址：CNN-Papers","link":"/2018/06/20/2018-06-20-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%87%8D%E8%A6%81%E8%AE%BA%E6%96%87%E8%B5%84%E6%BA%90%E5%90%88%E8%BE%91/"},{"title":"Linux文件系统","text":"文件系统计算机的文件系统是一种存储和组织计算机数据的方法，借助于文件系统，用户或程序对文件的访问和查找变得容易。 Linux支持的文件系统格式有：Ext2, Ext3, Ext4, ReiserFS, Xfs, Btrfs, FAT, FAT32, NTFS等。本文中，我并不打算展开对这些文件系统的详细解释，只是简单说出以下这些结论： Ext2, Ext3, Ext4是Linux系统上最常用的文件系统，发展到Ext4时已经十分稳定，没有特别要求时，一般都可以使用； ReiserFS是用B+树作为数据结构的文件系统，在处理小文件时有较好的性能，在实践中，ReiserFS在处理文件小于1k小文件时，甚至效率可以比ext3快约10倍; XFS使用64位管理空间，在多文件、大文件系统、空间利用率等方面相比Ext4更有优势。从CentOS 7开始，默认的文件系统就由此前的Ext4改为XFS了，由于文件规模的不断增大，日后Ext4可能会被XFS所取代。 Btrfs官方宣称其为“下一代文件系统”，虽然从理念上看Btrfs确实可能存在不错的效果，但截至目前，它的性能表现还是太差了，不建议使用。 【Ext4、XFS、Btrfs的详细对比，感兴趣的读者可以看看这篇Benchmark：EXT3 vs EXT4 vs XFS vs BTRFS linux filesystems benchmark】 Linux虽然支持FAT、FAT32、NTFS，但仅仅是为了兼容性，这三个文件系统很容易产生磁盘碎片（尽管NTFS上已有不小改善），Linux系统下一般是不会轻易使用的。 挂载点挂载点是linux中的磁盘文件系统的入口目录。 挂载点与其功能描述如下： / 根目录，存放系统命令和用户数据等（如果下面挂载点没有单独的分区，它们都将在根目录的分区中） /boot boot loader 的静态链接文件，存放与Linux启动相关的程序 /home 用户目录，存放普通用户的数据 /tmp 临时文件 /usr 是Red Hat Linux系统存放软件的地方,如有可能应将最大空间分给它： /usr/local 自已安装程序安装在此 /usr/X1186 X-Windows目录，存放一些X-Windows的配置文件 /usr/include 系统头文件，存储一些C语言的头文件 /usr/src Linux内核源代码，Linux系统所安装的内核源代码都保存在此 /usr/bin 对/bin目录的一些补充 /usr/sbin 对/sbin目录的一些补充 /usr/share/doc 用户文档 /var 不断变化的数据，服务器的一些服务、日志放在下面： /var/www：一般WEB存放网页的目录 /var/mail：postfix邮件的存放邮件的目录 /var/log：系统日志记录 /var/spool：存放一些邮件、新闻、打印队列等。 /opt （Option可选的）附加的应用程序软件包 /bin 基本命令执行文件 /dev 设备文件 /etc 主机特定的系统配置 /lib 基本共享库以及内核模块 /media 用于移动介质的挂载点 /mnt 用于临时挂载文件系统或者别的硬件设备（如光驱、软驱） /proc 系统信息的虚拟目录(2.4 和 2.6 内核)，这些信息是在内存中，由系统自己产生的。 /root root 用户的目录 /sbin 基本系统命令执行文件 /sys 系统信息的虚拟目录(2.6 内核) /srv 系统提供的用于 service 的数据 /lost+found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下。 当然上面这么多挂载点，实际上是没有比较每个目录都单独进行挂载，我们只需要根据自己的实际使用需要对个别目录进行挂载，这样系统结构看起来也会精简很多。最少的时候，我们只需要挂载/就可以了（当然这样并不好）。 分区根据挂载点的不同，对磁盘进行分区，选择最合适的文件系统，可以使计算机的性能、管理达到最优。 分区有很多的优点，例如： 1）保护数据；假如误操作，有分区的情况下就可能保护一部分数据免受误操作的影响；重装操作系统时，如果原先的系统中/home与/两个挂载点是对应着两个不同分区时，/home目录就不会受到影响； 2）针对不同挂载点的特性选择文件系统，开启不同的挂载选项（如是否需要即时同步，是否开启日志，是否启用压缩）以更好地发挥性能，比如对/var使用Reiserfs（这里面的文件通常小而繁杂），对/home使用XFS（超大容量支持可能是用户文件比较需求的），对/使用Ext4（更加稳定）。 3）分区可以缩小硬盘搜索范围，提高效率。 我举一例比较典型的分区方案： 挂载点 分区 文件系统 分配详情 /boot 启动分区 Ext4 只需要几百m即可，可以容纳下两三个内核足矣。 /swap 交换分区 Swap 物理内存的1.5-2倍，物理内存够大也可不分配 / 根分区 Ext4 桌面系统给个100G~200G足矣。 /home 家分区 XFS 剩下的可以全部分配给家分区 参考文献https://linux.cn/article-7083-1.html http://my.oschina.net/leejun2005/blog/290073 http://wuchong.me/blog/2014/07/19/linux-file-system/","link":"/2018/07/17/2018-07-17-Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"磁盘知识","text":"注：下文不特别区分“磁盘”、“硬盘”两个概念，认为“固态硬盘”也属于“磁盘”的一种。 磁盘接口IDE（Integrated Drive Electronics），即电子集成驱动器，是曾经主流的磁盘接口（同时也作为光驱的接口）。IDE又称ATA（Advanced Technology Attachment），即“高级技术附件”，在SATA（Serial ATA）出现后改名为PATA（Parallel ATA）。 SCSI（Small Computer System Interface），即小型计算机系统接口，可以连接硬盘、软驱、光驱、打印机等设备。SCSI出现的原因主要是因为IDE接口的硬盘转速太慢，传输速率太低。从原理层面看，SCSI与IDE一样使用的是并行技术，因此在SAS（Serial Attached SCSI）出现后SCSI就通常被称为并行SCSI了。 此后又出现了SATA（Serial Advanced Technology Attachment，串行高级技术附件）、SAS（Serial Attached SCSI）即串行连接SCSI 等接口，使用了串行技术，提高了数据传输速率。 我们可以将，SCSI和SAS划归为另一个系列，SCSI和SAS价格较高，在各自的年代都是用在高级的服务器上的，私人电脑上较少使用。而将IDE和SATA划归为一个系列，它们用于一般电脑或PC上，SATA在当下非常普遍。 命名在Linux上，IDE硬盘会被标识为hd，例如，在一个IDE接口上接着的两块硬盘会被分别标识为hda与hdb；出现SCSI硬盘后，Linux将其标识为sd，如sda、sdb。此后所有除IDE接口外的硬盘全部沿用SCSI硬盘的标识标准，即sd，没有再做改动。 机械硬盘与固态硬盘机械硬盘组成与容量机械硬盘由盘片、磁头及其它辅助机构组成。盘片（Disk）是硬盘中承载数据存储的介质，其上附着着磁粉，磁粉的S/N极将分别代表着二进制中的0和1，从而表示二进制数据。利用磁头（Head）的磁力控制指定的一些磁粉的方向，就存储了特定的信息。 下图是一个盘片的示意图： 如上图所示，盘片被分为很多条磁道（Track），即表面上的一些同心圆，磁道是从盘片外圈往内圈编号0磁道，1磁道…。每一个磁道又按512个字节为单位划分为等分，叫做扇区（Sector）。 磁盘是由多个盘片叠加在一起，互相之间由垫圈隔开。盘片上下两面各有一个磁头，每张盘片同一位置的磁道，组成了柱面（Cylinder ）。显然，磁道数=柱面数。 知道CHS（Cylinders、Heads、Sectors）的数量后，就可以确定磁盘的容量： 磁盘容量 = 柱面数（磁道数）× 磁头数 × 扇区数 × 扇区大小（512 Bytes） 固态硬盘固态硬盘没有采用磁性介质作为存储介质，而是使用半导体材料来存储数据，但“磁盘”这个词还是沿用在了固态硬盘上。 固态硬盘的内部构造十分简单，固态硬盘内主体其实就是一块PCB板，而这块PCB板上最基本的配件就是控制芯片，缓存芯片（部分低端硬盘无缓存芯片）和用于存储数据的闪存芯片。如下图所示： 固态硬盘也有扇区（Sector）的概念，与机械硬盘一致。 分区表（初始分区）之所以介绍一下磁盘的基础知识，是为了让大家更好地理解这一部分对硬盘初始分区的介绍。一块全新的硬盘，必须进行初始分区。初始分区可以分为MBR分区和GPT分区两种形式，对应MBR分区表和GPT分区表。 MBR分区形式 如上图所示，MBR分区形式下，硬盘的第一个扇区是主引导扇区，由三个部分组成：主引导记录（Master Boot Record，MBR）、硬盘分区表（Disk Partition Table，DPT）和硬盘有效标志。 MBR占446个字节，负责从活动分区（活动分区是即启动分区，安装有系统）中装载并运行系统引导程序。 DPT占64个字节，记录着硬盘中分区的数量以及每一分区的大小，每个分区的信息用16个字节表示，因此限制了分区的数量：不能超过4个主分区或者3主分区+1扩展分区，而扩展分区可以划分为任意数量的逻辑分区（扩展分区不可直接使用，需要转化为逻辑分区方可使用）【注1：逻辑分区数量受系统层级的限制，在Linux中，IDE硬盘最多有59个逻辑分区（5-63），SATA硬盘则有11个逻辑分区（5-15）】。 这16字节的具体内容是：启动标志、起止磁头号、起止扇区号、起止柱面号、隐含扇区数目(4个字节)、分区总扇区数目(4个字节)。这里又暴露了MBR分区的一个缺陷：用4个字节表示分区总扇区数， 最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2.2TB。 硬盘有效标志占2个字节，又被称为幻数（Magic Number），固定为55AA。如果该标志错误系统就不能启动。 GPT分区形式GPT是GUID（Globally Unique Identifier Partition Table） Partition Table的缩写，意即全局唯一标识符分区表。 GPT分区的LBA0是保护性MBR【注2：LBA意为逻辑块地址（Logical Bolck Address），每个逻辑块的大小是512字节，这是与扇区不同的定位方式 】，为了实现有限的兼容性，GPT仍然为MBR保留了这一扇区，用来阻止基于MBR的磁盘工具识别错误，从而覆盖GPT磁盘。 LBA1是GPT头（Primary GPT Header），LBA-1是备份GPT头（Secondary GPT Header），这两部分内容是一样的。GPT头的具体内容在此不做详细说明了。 LBA2-LBA33是分区表项，LBA-33 - LBA-2是备份分区表项，两部分内容也是一样的。GPT就是为了避免MBR的两大缺点：在GPT中，分区表项的数量有MBR的4项增多到128项，因此允许划分128个主分区；同时每项由MBR的16字节扩大到128字节，描述每个分区的开始扇区和结束扇区都用8个字节，因而最多支持2的64次方的扇区数，即支持最大约9.4ZB大小的分区。分区表项的具体内容如下： MBR VS. GPTMBR的缺点之一是不支持大于2.2T的分区，而GPT可以支持18EB的硬盘； MBR还有一个缺点是限制磁盘不能超过4个主分区或者3主分区+1扩展分区（包含随意数目的逻辑分区），而GPT则没有此限制。 GPT也有缺点，GPT分区硬盘在修复磁盘坏轨、做资料恢复、系统还原等任务时都会遇到麻烦，MBR则较为方便。 GPT 定义是 Intel提出的用以替代BIOS以实现对更多硬件的支持的规范：EFI( Extensible Firmware Interface ) 的一部分。例如，使用EFI/UEFI就可以引导GPT分区下的系统，可以将系统安装到2T容量以上的硬盘中。 考虑到兼容性，在EFI/UEFI中可以设置Legacy（传统）模式，从而引导MBR分区下的系统了。 而BIOS只可以引导MBR分区下的系统，不可以引导GPT分区下的系统（但支持GPT分区的硬盘做数据盘）。 查看分区类型Windows系统下 在“此电脑–管理–磁盘管理”中右键查看“磁盘0”或“磁盘1”属性，在“卷”选项卡下的“磁盘分区形式”即是该磁盘分区类型。 Linux系统下 使用命令查询： 1sudo parted -l Partition Table显示gpt则说明是GPT分区表，显示msdos则说明是MBR分区表。 MBR与GPT的选择1. 作为系统盘在Intel的大力推动下，现在很多PC、服务器出厂就是使用EFI/UEFI来启动系统的，磁盘的分区表也是GPT。 如果换上一块全新的磁盘，并希望使用MBR分区表，则需要在EFI/UEFI中切换Legacy模式，否则安装系统时会出错，例如：“Windows 无法安装到此磁盘。选定磁盘不是 GPT 分区类型的磁盘”。 2. 作为数据盘GPT或是MBR都可以被在EFI/UEFI引导的系统下使用，没有差别。如果需要大于2.2T的分区或是更高的主分区数要求，则选择GPT。 总的来说，作为系统盘，如果需要在2.2T容量以上的分区安装系统，或者对主分区数有更高要求，就必须使用GPT+EFI/UEFI，否则选择GPT+EFI/UEFI、MBR+BIOS或者MBR+EFI/UEFI（Legacy）都是可以的；而作为数据盘，选择的随意性更大，不需要考虑EFI/UEFI的影响。 我的建议是分区方式最好不要转换，可能会造成文件的丢失，如果确有必要，可以通过傲梅分区助手、DiskGenius来辅助，切不可使用Windows系统磁盘管理中的转换或是Linux安装系统的转换功能。","link":"/2018/07/21/2018-07-21-%E7%A3%81%E7%9B%98%E7%9F%A5%E8%AF%86/"},{"title":"打包TensorFlow Object Detection API","text":"问题来源对于TensorFlow Object Detection API我个人有两点不满： 安装： 官方安装指导要求使用者先克隆下整个models仓库，然后安装Protobuf，编译解压出object_detection模块。最后还要将object_detection模块与slim模块的目录export到PYTHONPATH中，这一操作在新打开Shell后都需要重新进行（当然，添加到环境变量配置文件中可以免除此麻烦）。整个过程是十分繁琐的。特别的，在Windows系统上，安装配置protobuf相对麻烦（安装指导中就没有给出Windows平台的情况），同时还存在bug，识别一些模型时会出问题【参见 Issue3002】。 使用：在object_detection的ipython tutorial中，使用了如下语句： 1from utils import label_map_util, visualization_utils 这里的utils是object_detection下的子模块。如果按照这个写法，运行脚本不在object_detection目录下就无法找到utils。 解决方法鉴于以上问题，我将object detection api打包成whl包和egg包，直接使用pip或者easy_install安装即可。 我将打包好的whl包与egg包分享出来，打包环境为Raspbian 9 Stretch（Python环境是3.5.3和Python2.7.13）、Win10 64位（Python环境是3.6.6和Python2.7.15）、Manjaro Linux 64位（Python环境是3.6.6和Python2.7.15）。下载地址：Pyhton_Packages_of_TensorFlow_Object_Detection_API 1. 安装依赖Tensorflow Object Detection API 需要如下依赖： [使用包管理工具安装（Linux）/系统级安装（Windows）] protobuf python-tk (tk in Manjaro)[使用pip安装] tensorflow pillow lxml jupyter matplotlib cython contextlib2 2. 安装下载的whl包或者egg包安装whl只需执行： 1pip install xxx.whl 安装egg只需执行： 1easy_install xxx.egg 3. 使用使用时，请使用标准的引用Python模块的子模块的用法，对于object_detection的utils或是其他子模块，请使用： 1from object_detection.utils import label_map_util, visualization_utils 这样运行脚本不管放在哪里，都是可以搜索到utils并执行的。","link":"/2018/07/24/2018-07-24-%E6%89%93%E5%8C%85TensorFlow%20Object%20Detection%20API/"},{"title":"卷积神经网络详解(一)——基础知识","text":"1. 卷积神经网络的组成1981年诺贝尔医学奖得主，神经生物学家David Hubel 和Torsten Wiesel对人脑视觉系统的研究表明：人脑视觉系统首先通过眼睛来成像，图像通过瞳孔、晶状体最终在视网膜上成像。视网膜上布满了大量的光感受细胞，可以把光刺激转换为神经冲动，神经冲动通过视觉通路传递到大脑的初级视觉皮层（Primary Visual Cortex，V1），V1初步处理得到边缘、方向等特征信息，而后经由V2的进一步抽象得到轮廓、形状等特征信息，如此迭代地经由多层（V1层至V5层）的抽象后得到高层特征。高层特征是低层特征的组合^5，从低层特征到高层特征的抽象过程中，语义的表现越来越清晰，存在的歧义越来越少，对目标的识别也就越来越精确。这就是人脑视觉系统的分层处理机制。 视觉皮层上的细胞有简单细胞（Simple Cell）与复杂细胞（Complex Cell）之分，这两种细胞的共同点是他们都只对特定方向的条形图样刺激有反应，而他们的主要区别是简单细胞对应的视网膜上的光感受细胞所在的区域比复杂细胞所对应的区域来得小，这个区域被称为感受野（Receptive Field）。这就是人脑视觉系统的感受野机制。 1980年，日本学者Kunihiko Fukushima提出感知机模型（Neocognitron），提出使用卷积层来模拟视觉细胞对特定图案的反应、使用池化层模拟感受野的方法。卷积神经网络的设计深受这个方法的影响，其基本结构为： 具体说来，卷积层用于提取不同的图像特征，有减少参数数量、保留空间信息的作用；池化层用于模拟感受野，有选取特征、减少参数数量的作用，同时引入微小平移不变性^1；而激活层的设置则是为了引入非线性因子，提升模型的表达能力，这是神经网络中普遍采用的。 2. 卷积层2.1 图像的局部相关性图像是具有局部相关性的一类数据^3，其局部相关性是指组成图像的每个像素点与其周围的像素点是有关联的，而图像上距离较远的像素相关性较弱，因此处理图像时实际上没必要每个神经元都对全局图像进行感知。 2.2 全连接网络用于图像处理以MNIST手写数字识别为例，该数据集中的图像为（28，28，1）的灰度图像，这个图像由28 * 28个像素点（Pixel）构成，每个像素点有一个通道（Channel）。如果使用全连接网络（即网络中的神经元与相邻层上的每个神经元均连接），那么输入层有28 * 28 =784个神经元，假设hidden层采用了15个神经元^2，输出层是10个神经元，那么参数个数(w和b)就有：784 * 15 * 10+15+10=117625个。即使在这种情况下，参数量都十分庞大了，如果输入图像的像素点更多、全连接网络的隐藏层层数更多、隐藏层神经元数量更多，参数量就会更加庞大。大量的参数很容易导致网络过拟合，而且每进行一次反向传播计算量都是巨大的，无论从调参还是计算资源的角度都不建议用全连接网络做图像处理。此外，全连接网络认为“每个输入值都是平等的”，它将输入视为一维向量，并不关心这个像素是第几行、第几列的像素，忽视了空间信息，用于图像这种具有空间局部相关性的数据也是不合适的。 2.3 减少参数数量在图像局部相关性的支撑下，卷积连接应用而生。为简化说明，来看一个简单的例子：在下面的这张图中，输入为3 * 3 = 9个像素，如果将其与16个隐藏层神经元全连接，就会有9 * 16 = 144个连接，也就有144个权值。 为减少连接数，并且基于图像局部相关性的假设，可以仅取四个位置相近（注意图像的Width和Height两个维度）的像素作为输入，四个像素与同一个神经元进行连接，连接的权值记为$w_0$、$w_1$、$w_2$、$w_3$， 如下图所示。 这种连接方式又可看作是数学上的卷积操作^4，其中这一组权值就被称为卷积核， 如下图右图所示，因此得名卷积连接。 我们将这个卷积操作在输入图像上滑动起来，自然地，连接的神经元也向下滑动，连接的权值仍记为$w_0$、$w_1$、$w_2$、$w_3$，如下图所示。此时注意，这个卷积操作要覆盖图像上的所有9个像素，需要滑动四次，因此对应着四个神经元。图像的四部分局部像素与这四个神经元连接时共享同一套权值（简洁地说，这四个神经元共享一套权值），这就是所谓的“权值共享”的概念。这组权值又叫做卷积核。 卷积连接方式使得每个神经元所感知的图像的范围由整张图缩减到了4个像素点，从而减少了权值的数量，又采取了“权值共享”的方法，进一步减少了参数的数量。 允许我们对图像进行卷积操作的理论依据就是图像的局部相关性：卷积神经网络的设计认为每个神经元没必要对全局图像进行感知，只需对局部像素按空间位置进行局部连接即可。 2.4 提取图像特征卷积层每次用一个卷积核在图像上滑动，来提取图像的某一显著特征。卷积核可以找到图中和卷积核自身最相似的部分，而且相似度越高，得到的响应值越大。 图7中上面一排的照片是5架战斗机，把其中一架战斗机的图像截出来作为卷积核，与原图像进行卷积，得到结果如下排图像所示。可以看到，每架战斗机所在的位置都得到了一个极大的响应。因此，通过设置合理的损失函数，在卷积神经网络中使用反向传播算法，最终可以学习到相应于目标结果的卷积核，在Inference的时候就可以提取出有效特征。 2.5 保留空间信息与全连接网络相比，卷积网络没有将图像展开为一维向量，而是使用卷积核在原图像上滑动来提取特征，因此保留了原图像的局部空间信息。图7中上面一排右边的照片是由左边照片对5架战斗机平移得到的。经过同样的卷积操作后，得到的特征响应图相当于左边的特征响应图做相应的平移。这是卷积神经网络的局部连接和权值共享带来的“同变性（Equivariance）”[^7]，亦是卷积神经网络可以保留图像空间信息的体现。 [^7]: 关于 CNN对图像特征的 位移、尺度、形变不变性的理解 2.6 卷积操作的补充 卷积核（Filter） 在数学定义上，矩阵的卷积（Convolution）操作为：首先将卷积核进行翻转，构成一个卷积核的镜像，然后使用该镜像和前面矩阵相应位置进行点乘。如下面所示： 步长（Step） 卷积操作每次移动的单位数称为步长。 填充（Padding）为了控制输出的尺寸，可以采用填充的方法。例如在步长为2的情况下，输出尺寸原为5 * 5，如果想使输出尺寸为3 * 3， 可以在输入外围添加一圈0，在这种情况下，输出的尺寸就是3 * 3。 3. 激活层激活层算不上卷积神经网络的特色，这里就不详细介绍了，简而言之，激活层的作用就是引入非线性因子，提升模型的表达能力。 4. 池化层卷积神经网络在卷积层和激活层之后又增加了池化层，用来模拟感受野，以达到选取特征、减少参数数量的作用，同时引入微小平移不变性。 4.1 特征选取池化的一个功能是对特征的选取，卷积神经网络中常用的有Average Pooling和Maximum Pooling。Average Pooling，即对池化区域内特征点求平均，Maximum Pooling则对池化区域内特征点取最大。Average Pooling更能保留图片的背景信息，如果背景中也含有有效信息，Average Pooling就更合适；Maximum Pooling会忽略背景信息，在有噪声的情况下则更有效。通过池化，CNN进一步减少了参数数量（降维）。 4.2 微小平移不变性在局部连接和权值共享的作用下，平移后图像的特征映射图与特征映射图直接做对应的平移得到的结果差别不大，即前面所述的同变性。 此时再进行池化，以Maximum Pooling为例，如下图所示，在左图中得到的池化结果是11，在右图中得到的池化结果也是11，体现了平移不变性。 需要指出的是，池化的平移不变性是有限的，即所说的微小平移不变性。如果平移超出了感受野的位置，平移不变性就难以体现。 5. 分层表达前已述及，人脑视觉系统存在分层处理的机制，卷积神经网络用多层的网络来模拟人脑视觉系统的分层处理。通过多层的卷积神经网络，计算机逐步“理解”一幅图像大致遵循这样的过程：像素–&gt;边缘–&gt;基本形状–&gt;复杂图案–&gt;更复杂图案。例如，在学习一张车的图片时，浅层的卷积层能从最基本的像素中学习到边缘特征，较深层点的可以学习到圆形等基本形状，再经过几层可以学习到轮胎、车身等图案特征，最后可以学习到车的整体特征。 6. 卷积的可视化与解释性深度学习的解释性学界仍在研究当中。目前对于卷积神经网络，仅能通过可视化提供简单的解释。 6.1 边缘检测先解释卷积层如何做边缘检测。图片最常做的边缘检测有两类：垂直边缘（Vertical Edges）检测和水平边缘（Horizontal Edges）检测。 以垂直边缘检测为例，原始灰度图像尺寸为 6x6，卷积核尺寸为 3x3，不做Padding，Stride = 1，卷积后得到的特征映射图尺寸为 4x4，得到结果如下： 在灰度图像中，０代表灰，正值表示白，值越大越白，负值代表黑，值越小越黑。本例的原始图像和卷积后的特征映射图，有图例所示的黑白灰分布，提取出了垂直边缘。 6.2 响应相似图形这部分可以参考2.4节。 6.3 特征响应图可视化相关研究[^6]中，曾实现了对特征映射图的可视化。直接看一下结果： 目前的研究虽然还是不能完全解释CNN，但是通过可视化，我们发现CNN学习到的特征确实如我们所预期的呈现分层特性，底层是一些边缘角点以及颜色的抽象特征，越到高层则越呈现出具体的特征，与人类视觉系统类似。 [^6]: Deep Visualization:可视化并理解CNN 7. 卷积神经网络为什么有效 从神经科学角度：卷积神经网络模仿了人脑视觉系统的分层处理机制以及感受野机制； 从统计角度：卷积神经网络抓住了图像的局部相关性（Spatially-local Correlation）； 从正则化的角度：由于局部连接、权值共享和池化，降低了模型参数数量，控制了模型复杂度，可有效避免模型过拟合。 关键词 ： 局部感受野、权值共享、时间/空间亚采样 参考文献深度学习与计算机视觉——算法原理、框架应用与代码实现Derivation of Convolutional Neural Network from Fully Connected Network Step-By-Step卷积神经网络CNN原理详解(一)——基本原理CNN为什么有效卷积神经网络为什么具有平移不变性？吴恩达 DeepLearning.ai 课程提炼笔记（4-1）卷积神经网络 — 卷积神经网络基础CNN十大问CNN中减少网络的参数的三个思想","link":"/2019/01/22/2019-01-22-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3(%E4%B8%80)%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Computer","slug":"Computer","link":"/tags/Computer/"},{"name":"Operation&amp;Maintenance","slug":"Operation-Maintenance","link":"/tags/Operation-Maintenance/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/tags/Raspberry-Pi/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"}],"categories":[{"name":"Computer","slug":"Computer","link":"/categories/Computer/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/categories/Deep-Learning/"},{"name":"Basics of Computers","slug":"Computer/Basics-of-Computers","link":"/categories/Computer/Basics-of-Computers/"},{"name":"Linux","slug":"Computer/Linux","link":"/categories/Computer/Linux/"},{"name":"Neural Networks","slug":"Deep-Learning/Neural-Networks","link":"/categories/Deep-Learning/Neural-Networks/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/categories/Raspberry-Pi/"},{"name":"Deployment","slug":"Deep-Learning/Deployment","link":"/categories/Deep-Learning/Deployment/"},{"name":"CNN Special Column","slug":"Deep-Learning/Neural-Networks/CNN-Special-Column","link":"/categories/Deep-Learning/Neural-Networks/CNN-Special-Column/"}]}